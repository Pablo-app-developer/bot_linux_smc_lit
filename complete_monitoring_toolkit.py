#!/usr/bin/env python3
"""
TOOLKIT COMPLETO DE MONITOREO PROFESIONAL - BOT SMC-LIT
=======================================================
Herramienta todo-en-uno para monitoreo, versionado y evaluaciones del bot.
Sistema seguro de credenciales implementado.
"""

import os
import sys
import json
import subprocess
import time
import threading
from datetime import datetime
import logging

# Importar sistemas seguros
try:
    from professional_monitoring_system import ProfessionalMonitoringSystem
    from version_management_system import VersionManagementSystem
    from secure_config_manager import SecureConfigManager, VPSCredentials
except ImportError:
    print("‚ö†Ô∏è  M√≥dulos no encontrados. Ejecutando desde archivos locales...")

class CompleteMonitoringToolkit:
    def __init__(self):
        # Usar gestor seguro de configuraci√≥n
        self.config_manager = SecureConfigManager()
        self.vps_credentials = self._get_secure_credentials()
        
        self.monitoring_system = None
        self.version_manager = None
        self.setup_logging()
        
    def _get_secure_credentials(self) -> dict:
        """Obtener credenciales de forma segura"""
        vps_creds = self.config_manager.get_vps_credentials()
        
        if not vps_creds:
            print("‚ö†Ô∏è  CREDENCIALES NO CONFIGURADAS")
            print("   Ejecuta: python3 secure_config_manager.py")
            print("   Para configurar credenciales seguras.")
            # Usar credenciales temporales de fallback (solo para demo)
            return {
                'host': 'PLEASE_CONFIGURE',
                'user': 'PLEASE_CONFIGURE', 
                'password': 'PLEASE_CONFIGURE',
                'port': 22
            }
        
        return {
            'host': vps_creds.host,
            'user': vps_creds.user,
            'password': vps_creds.password,
            'port': vps_creds.port
        }
        
    def setup_logging(self):
        """Configurar logging centralizado"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler('complete_monitoring.log'),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger('CompleteToolkit')
        
        # Log seguro (sin credenciales)
        self.logger.info(f"Toolkit initialized for VPS: {self.vps_credentials['host']}")
    
    def install_dependencies(self):
        """Instalar dependencias necesarias"""
        print("üì¶ Instalando dependencias del sistema de monitoreo...")
        try:
            subprocess.run([
                sys.executable, '-m', 'pip', 'install', 
                'flask', 'plotly', 'pandas', 'requests', 'cryptography'
            ], check=True, capture_output=True)
            print("‚úÖ Dependencias instaladas correctamente")
            return True
        except subprocess.CalledProcessError as e:
            print(f"‚ùå Error instalando dependencias: {e}")
            return False
    
    def start_monitoring_dashboard(self):
        """Iniciar dashboard de monitoreo en segundo plano"""
        try:
            if not self.monitoring_system:
                from professional_monitoring_system import ProfessionalMonitoringSystem
                self.monitoring_system = ProfessionalMonitoringSystem(self.vps_credentials)
            
            print("üöÄ Iniciando dashboard de monitoreo...")
            print("üåê Accede a: http://localhost:5000")
            
            # Ejecutar en thread separado
            dashboard_thread = threading.Thread(
                target=self.monitoring_system.run_dashboard,
                daemon=True
            )
            dashboard_thread.start()
            
            return True
            
        except Exception as e:
            print(f"‚ùå Error iniciando dashboard: {e}")
            return False
    
    def quick_bot_status(self):
        """Estado r√°pido del bot"""
        try:
            status_command = f"""
            sshpass -p '{self.vps_credentials['password']}' ssh -o StrictHostKeyChecking=no -p {self.vps_credentials['port']} {self.vps_credentials['user']}@{self.vps_credentials['host']} '
                echo "=== BOT STATUS ===" &&
                ps aux | grep main_unlimited | grep -v grep | wc -l &&
                echo "=== LAST ACTIVITY ===" &&
                tail -3 /home/smc-lit-bot/*.log 2>/dev/null | grep "An√°lisis" | tail -1 &&
                echo "=== SYSTEM LOAD ===" &&
                uptime | awk "{{print \\$3, \\$4, \\$5}}"
            '
            """
            
            result = subprocess.run(status_command, shell=True, capture_output=True, text=True)
            
            if result.returncode == 0:
                lines = result.stdout.strip().split('\n')
                bot_running = int(lines[1]) > 0 if len(lines) > 1 else False
                
                print("\nüìä ESTADO R√ÅPIDO DEL BOT")
                print("=" * 30)
                print(f"ü§ñ Bot Status: {'üü¢ RUNNING' if bot_running else 'üî¥ STOPPED'}")
                print(f"üìà √öltima actividad: {lines[3] if len(lines) > 3 else 'No disponible'}")
                print(f"‚ö° Carga del sistema: {lines[5] if len(lines) > 5 else 'No disponible'}")
                print("=" * 30)
                
                return bot_running
            else:
                print(f"‚ùå Error obteniendo estado: {result.stderr}")
                return False
                
        except Exception as e:
            print(f"‚ùå Error: {e}")
            return False
    
    def get_metrics_for_evaluation(self):
        """Obtener m√©tricas completas para evaluaci√≥n con asistente"""
        try:
            # Comando simplificado que sabemos que funciona
            metrics_command = [
                'sshpass', '-p', self.vps_credentials['password'],
                'ssh', '-o', 'StrictHostKeyChecking=no',
                '-p', str(self.vps_credentials['port']),
                f"{self.vps_credentials['user']}@{self.vps_credentials['host']}",
                'echo "=== BOT STATUS ===" && ps aux | grep main_unlimited | grep -v grep && echo "=== SYSTEM METRICS ===" && free -h && echo "=== CPU USAGE ===" && top -bn1 | grep "Cpu(s)" && echo "=== UPTIME ===" && uptime && echo "=== TIMESTAMP ===" && date'
            ]
            
            result = subprocess.run(metrics_command, capture_output=True, text=True)
            
            if result.returncode == 0:
                return {
                    'timestamp': datetime.now().isoformat(),
                    'vps_ip': self.vps_credentials['host'],
                    'raw_metrics': result.stdout,
                    'collection_success': True
                }
            else:
                return {
                    'timestamp': datetime.now().isoformat(),
                    'error': result.stderr,
                    'collection_success': False
                }
                
        except Exception as e:
            return {
                'timestamp': datetime.now().isoformat(),
                'error': str(e),
                'collection_success': False
            }
    
    def create_evaluation_report(self, request_description: str = "Evaluaci√≥n general"):
        """Crear reporte completo para evaluaci√≥n"""
        print(f"üìä Generando reporte de evaluaci√≥n: {request_description}")
        
        # Obtener m√©tricas completas
        metrics = self.get_metrics_for_evaluation()
        
        # An√°lisis b√°sico
        analysis = {
            'request': request_description,
            'vps_info': {
                'ip': self.vps_credentials['host'],
                'status': 'operational' if metrics['collection_success'] else 'error'
            },
            'metrics_collected': metrics,
            'recommendations': [],
            'timestamp': datetime.now().isoformat()
        }
        
        # Guardar reporte
        report_file = f"evaluation_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        with open(report_file, 'w') as f:
            json.dump(analysis, f, indent=2)
        
        print(f"üìã Reporte guardado: {report_file}")
        print("\nü§ñ DATOS PARA EVALUACI√ìN CON ASISTENTE:")
        print("=" * 50)
        print(f"üìä Estado de recolecci√≥n: {'‚úÖ Exitoso' if metrics['collection_success'] else '‚ùå Error'}")
        print(f"‚è∞ Timestamp: {analysis['timestamp']}")
        print(f"üåê VPS IP: {self.vps_credentials['host']}")
        print(f"üìù Solicitud: {request_description}")
        print("=" * 50)
        
        return analysis
    
    def update_bot_version(self, version: str = None, description: str = None):
        """Actualizar versi√≥n del bot"""
        try:
            if not self.version_manager:
                from version_management_system import VersionManagementSystem
                self.version_manager = VersionManagementSystem(self.vps_credentials)
            
            if not version:
                version = input("N√∫mero de versi√≥n (ej: 1.1.0): ")
            if not description:
                description = input("Descripci√≥n de cambios: ")
            
            changes = input("Lista de cambios (separados por coma): ").split(',')
            changes = [change.strip() for change in changes if change.strip()]
            
            print(f"üöÄ Creando release v{version}...")
            package = self.version_manager.create_release_package(version, description, changes)
            
            print(f"üì¶ Desplegando al VPS...")
            result = self.version_manager.deploy_to_vps(package)
            
            if result.success:
                print("‚úÖ Actualizaci√≥n exitosa!")
                print(f"üìã Versi√≥n: {result.version}")
                print(f"üíæ Backup creado: {'S√≠' if result.backup_created else 'No'}")
                return True
            else:
                print("‚ùå Actualizaci√≥n fall√≥:")
                for error in result.errors:
                    print(f"   - {error}")
                
                if result.rollback_available:
                    rollback = input("¬øHacer rollback autom√°tico? (y/n): ")
                    if rollback.lower() == 'y':
                        if self.version_manager.rollback_to_backup():
                            print("‚úÖ Rollback exitoso")
                        else:
                            print("‚ùå Rollback fall√≥")
                return False
                
        except Exception as e:
            print(f"‚ùå Error en actualizaci√≥n: {e}")
            return False
    
    def interactive_menu(self):
        """Men√∫ interactivo principal"""
        while True:
            print("\nü§ñ TOOLKIT COMPLETO - BOT SMC-LIT")
            print("=" * 40)
            print("1. üìä Estado r√°pido del bot")
            print("2. üåê Iniciar dashboard web")
            print("3. üìã Generar reporte de evaluaci√≥n")
            print("4. üîÑ Actualizar versi√≥n del bot")
            print("5. üìà M√©tricas para evaluaci√≥n")
            print("6. üîß Reiniciar bot")
            print("7. üíæ Hacer backup")
            print("8. üö™ Salir")
            
            choice = input("\nSelecciona una opci√≥n (1-8): ").strip()
            
            if choice == "1":
                self.quick_bot_status()
            
            elif choice == "2":
                if self.install_dependencies():
                    self.start_monitoring_dashboard()
                    input("Presiona Enter para continuar...")
            
            elif choice == "3":
                request = input("Describe qu√© quieres evaluar: ")
                self.create_evaluation_report(request or "Evaluaci√≥n general")
            
            elif choice == "4":
                self.update_bot_version()
            
            elif choice == "5":
                metrics = self.get_metrics_for_evaluation()
                print("\nüìä M√âTRICAS PARA COPIAR AL ASISTENTE:")
                print("=" * 45)
                print(json.dumps(metrics, indent=2))
            
            elif choice == "6":
                print("üîÑ Reiniciando bot...")
                restart_cmd = f"""
                sshpass -p '{self.vps_credentials['password']}' ssh -o StrictHostKeyChecking=no {self.vps_credentials['user']}@{self.vps_credentials['host']} '
                    pkill -f main_unlimited.py &&
                    cd /home/smc-lit-bot &&
                    source venv/bin/activate &&
                    screen -dmS smc-bot python3 main_unlimited.py
                '
                """
                result = subprocess.run(restart_cmd, shell=True, capture_output=True)
                print("‚úÖ Bot reiniciado" if result.returncode == 0 else "‚ùå Error reiniciando")
            
            elif choice == "7":
                print("üíæ Creando backup...")
                if not self.version_manager:
                    from version_management_system import VersionManagementSystem
                    self.version_manager = VersionManagementSystem(self.vps_credentials)
                
                if self.version_manager.backup_current_version():
                    print("‚úÖ Backup creado exitosamente")
                else:
                    print("‚ùå Error creando backup")
            
            elif choice == "8":
                print("üëã ¬°Hasta luego!")
                break
            
            else:
                print("‚ùå Opci√≥n no v√°lida")

def main():
    """Funci√≥n principal"""
    toolkit = CompleteMonitoringToolkit()
    
    print("üöÄ TOOLKIT COMPLETO DE MONITOREO - BOT SMC-LIT")
    print("=" * 55)
    print("üåê VPS: 107.174.133.202")
    print("ü§ñ Bot: main_unlimited.py")
    print("üí∞ Demo: $1,000 USD - Sin limitaciones")
    print("=" * 55)
    
    # Verificar estado inicial
    if toolkit.quick_bot_status():
        print("‚úÖ Bot est√° funcionando correctamente")
    else:
        print("‚ö†Ô∏è  Bot podr√≠a necesitar atenci√≥n")
    
    # Iniciar men√∫ interactivo
    toolkit.interactive_menu()

if __name__ == "__main__":
    main() 